<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shelfsignals – Sekula Library Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #f7f7f7;
      --primary: #222;
      --accent: #1f77b4;
      --muted: #888;
      --border: #ddd;
      --chip-bg: #e0e7f5;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--primary);
    }

    header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: #fff;
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    header p {
      margin: 0.3rem 0 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .header-controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    main.layout {
      display: grid;
      grid-template-columns: 260px minmax(0, 2.2fr) minmax(280px, 1.3fr);
      gap: 1rem;
      padding: 1rem 1.5rem 1.5rem;
    }

    @media (max-width: 960px) {
      main.layout {
        grid-template-columns: 1fr;
        padding: 0.75rem;
        gap: 0.75rem;
      }
      aside.detail { order: 3; }
      section.controls { order: 1; }
      section.shelf-view { order: 2; }
      
      header {
        padding: 0.75rem 1rem;
      }
      
      header h1 {
        font-size: 1rem;
      }
      
      header p {
        font-size: 0.8rem;
      }
      
      .cluster-map {
        grid-template-columns: 1fr;
      }
      
      .location-overview {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      header h1 {
        font-size: 0.9rem;
      }
      
      .shelf-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
    }

    section.controls, section.shelf-view, aside.detail {
      background: #fff;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      padding: 0.75rem 1rem 1rem;
      overflow: hidden;
    }

    section.controls h2,
    section.shelf-view h2,
    aside.detail h2 {
      margin: 0 0 0.5rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .filter-group {
      margin-bottom: 0.75rem;
    }

    .filter-group input[type="text"],
    .filter-group select {
      width: 100%;
      padding: 0.45rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 0.35rem;
      font-size: 0.9rem;
    }

    .filter-group label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      cursor: pointer;
    }

    .filter-group input[type="checkbox"] {
      accent-color: var(--accent);
    }

    .legend-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: var(--chip-bg);
      font-size: 0.8rem;
      margin: 0.1rem 0.15rem 0.1rem 0;
    }

    .legend-chip span.symbol {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border: 1px solid var(--accent);
    }

    .shelf-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.5rem;
      max-height: calc(100vh - 200px);
      overflow: auto;
      padding-right: 0.25rem;
    }

    .shelf-segment {
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      padding: 0.4rem 0.5rem 0.5rem;
      background: #fafafa;
      cursor: pointer;
      transition: box-shadow 0.12s ease, border-color 0.12s ease,
                  transform 0.12s ease, background 0.12s ease;
    }

    .shelf-segment:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .shelf-segment[data-dimmed="true"] {
      opacity: 0.35;
    }

    .shelf-segment-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.3rem;
    }

    .shelf-label {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .shelf-count {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .shelf-themes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .theme-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      border: 1px solid var(--accent);
    }

    .theme-dot[data-theme="image"]  { border-style: solid; }
    .theme-dot[data-theme="labor"]  { border-style: dashed; }
    .theme-dot[data-theme="sea"]    { border-radius: 0; }
    .theme-dot[data-theme="state"]  { border-width: 2px; }
    .theme-dot[data-theme="theory"] { border-style: dotted; }

    .detail-body {
      max-height: calc(100vh - 220px);
      overflow: auto;
      padding-right: 0.25rem;
    }

    .book-card {
      border-bottom: 1px solid var(--border);
      padding: 0.4rem 0 0.4rem;
    }

    .book-title {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 0.1rem;
    }

    .book-meta {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .book-subjects {
      margin-top: 0.2rem;
      font-size: 0.78rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.05rem 0.35rem;
      font-size: 0.7rem;
      margin-right: 0.2rem;
      margin-top: 0.1rem;
    }

    .muted {
      color: var(--muted);
    }

    /* Shelf rows / spines */
    .shelf-rows {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      max-height: calc(100vh - 200px);
      overflow: auto;
      padding-right: 0.35rem;
    }

    .shelf-row {
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.45rem 0.55rem 0.45rem;
      background: #fff;
    }

    .shelf-row-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.3rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .shelf-row-label {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .shelf-row-count {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .spines {
      display: flex;
      gap: 2px;
      align-items: flex-end;
      flex-wrap: wrap;
      padding: 0.15rem 0;
    }

    .spine-run {
      display: flex;
      gap: 3px;
      align-items: flex-end;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .spine-run-label {
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    .spine {
      width: 8px;
      height: 52px;
      border-radius: 2px;
      border: 1px solid var(--border);
      background: #fff;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, opacity 0.12s ease;
      cursor: pointer;
      position: relative;
    }

    .spine[data-highlight="true"] {
      border-color: var(--accent);
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      transform: translateY(-2px);
    }

    .spine[data-dimmed="true"] {
      opacity: 0.25;
    }

    .spine::after {
      content: "";
      position: absolute;
      inset: 4px 2px;
      border-left: 2px solid var(--accent);
      opacity: 0.5;
    }

    .spine:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      transform: translateY(-3px);
    }

    .pill.note {
      background: #f2f5fb;
      border-color: var(--accent);
      color: var(--primary);
    }

    .location-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin: 0.2rem 0 0.2rem;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
      font-size: 0.8rem;
      transition: border-color 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
    }

    .chip[data-active="true"] {
      border-color: var(--accent);
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      background: #eef2fb;
    }

    .class-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.3rem 0 0.4rem;
      font-size: 0.8rem;
    }

    .class-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.2rem 0.45rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: #fff;
    }

    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid var(--border);
    }

    /* Cluster map */
    .cluster-panel {
      margin-top: 0.6rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.55rem 0.65rem;
      background: #fff;
    }

    .cluster-map {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 0.6rem;
      margin-top: 0.4rem;
    }

    .cluster-card {
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.55rem;
      background: #fafafa;
    }

    .cluster-card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.4rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .cluster-zone {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .cluster-count {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .cluster-cells {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .cluster-cells[data-collapsed="true"] {
      display: none;
    }

    .cluster-cell {
      border: 1px solid var(--border);
      border-radius: 0.4rem;
      padding: 0.35rem 0.45rem;
      background: #fff;
      position: relative;
    }

    .cluster-cell[data-active="true"] {
      border-color: var(--accent);
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }

    .cluster-cell-label {
      font-weight: 600;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
    }

    .cluster-bar {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent), #cdd9f2);
      margin: 0.25rem 0 0.35rem;
      opacity: 0.8;
    }

    .cluster-meta {
      font-size: 0.78rem;
      color: var(--muted);
      line-height: 1.3;
    }

    .cluster-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .link-button {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 0.35rem;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .link-button:hover {
      border-color: var(--accent);
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }

    .location-overview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 0.5rem;
      margin: 0.35rem 0 0.4rem;
    }

    .location-card {
      border: 1px solid var(--border);
      border-radius: 0.45rem;
      padding: 0.4rem 0.5rem;
      background: #fafafa;
      cursor: pointer;
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .location-card:hover {
      border-color: var(--accent);
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }

    .loc-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .loc-count {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .bar {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent), #cdd9f2);
    }

    .bar-row {
      margin-top: 0.25rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.78rem;
    }

    .icon-button {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 0.35rem;
      padding: 0.35rem 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .icon-button:hover {
      border-color: var(--accent);
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }

    .location-section {
      border: 1px solid var(--border);
      border-radius: 0.55rem;
      margin-bottom: 0.5rem;
      background: #fdfdfd;
      padding: 0.45rem 0.6rem 0.6rem;
    }

    .location-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
    }

    .location-title {
      font-weight: 700;
      font-size: 0.95rem;
    }

    .location-count {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .section-subline {
      margin: 0 0 0.35rem;
      font-size: 0.82rem;
      color: var(--muted);
    }

    .location-body {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 0.6rem;
      z-index: 9999;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--primary);
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #dfe6f3;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Config modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .modal {
      background: #fff;
      border-radius: 0.6rem;
      padding: 1rem;
      width: min(480px, 90vw);
      border: 1px solid var(--border);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }

    .modal h3 {
      margin: 0 0 0.5rem;
    }

    .palette-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.6rem;
    }

    .palette-card {
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.5rem;
      cursor: pointer;
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .palette-card[data-active="true"] {
      border-color: var(--accent);
      box-shadow: 0 1px 5px rgba(0,0,0,0.08);
    }

    .swatch-row {
      display: flex;
      gap: 4px;
      margin-top: 0.35rem;
    }

    .swatch-square {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid var(--border);
    }

    /* About Modal */
    .about-modal {
      background: #fff;
      border-radius: 0.6rem;
      padding: 1.5rem;
      width: min(600px, 90vw);
      max-height: 85vh;
      overflow-y: auto;
      border: 1px solid var(--border);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }

    .about-modal h3 {
      margin: 0 0 1rem;
      font-size: 1.4rem;
      color: var(--primary);
    }

    .about-modal h4 {
      margin: 1.2rem 0 0.5rem;
      font-size: 1rem;
      color: var(--primary);
    }

    .about-modal p {
      margin: 0.5rem 0;
      line-height: 1.6;
      color: var(--primary);
    }

    .about-modal ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
      line-height: 1.6;
    }

    .about-modal a {
      color: var(--accent);
      text-decoration: none;
    }

    .about-modal a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .modal, .about-modal {
        width: 95vw;
        padding: 1rem;
      }
      
      .about-modal h3 {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Shelfsignals · Allan Sekula Library</h1>
      <p>Prototype overlay generated from catalog data – for internal discussion only.</p>
    </div>
    <div class="header-controls">
      <button id="openAbout" class="icon-button" title="About ShelfSignals">ℹ️</button>
      <button id="openConfig" class="icon-button" title="Color settings">⚙️</button>
    </div>
  </header>
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <div>Loading Sekula inventory…</div>
  </div>
  <div id="configBackdrop" class="modal-backdrop">
    <div class="modal">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;">
        <h3 style="margin:0;">Color palettes</h3>
        <button id="closeConfig" class="icon-button" type="button">Close</button>
      </div>
      <p class="muted" style="margin-top:0.2rem;">Choose a palette for class-color spines and accents.</p>
      <div id="paletteGrid" class="palette-grid"></div>
    </div>
  </div>
  <div id="aboutBackdrop" class="modal-backdrop">
    <div class="about-modal">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;margin-bottom:0.5rem;">
        <h3 style="margin:0;">About ShelfSignals</h3>
        <button id="closeAbout" class="icon-button" type="button" aria-label="Close about dialog">Close</button>
      </div>
      <p>
        <strong>ShelfSignals</strong> is a system-agnostic analytics framework for extracting structure,
        patterns, and insights from collection inventories. It is designed for research
        libraries, archives, and any environment where catalog metadata and numbering
        systems contain implicit signals about provenance, organization, or workflow history.
      </p>
      
      <h4>Background</h4>
      <p>
        This prototype visualizes the <strong>Allan Sekula Library</strong>, a research collection focused on 
        photography, labor, maritime culture, and critical theory. The library contains materials 
        that span art, politics, geography, and social documentary. ShelfSignals reveals thematic 
        patterns and organizational structures through visual analysis of call numbers, subjects, 
        and provenance metadata.
      </p>
      
      <h4>Features</h4>
      <ul>
        <li><strong>Signal Detection:</strong> Automatically identifies thematic signals (image, labor, capital, sea, etc.) from subject headings and notes</li>
        <li><strong>Visual Shelf Representation:</strong> Displays collection as interactive "spines" grouped by call number ranges</li>
        <li><strong>Cluster Analysis:</strong> Shows how themes concentrate in different physical locations and LC classes</li>
        <li><strong>Search & Filter:</strong> Real-time filtering by signals, locations, and search terms</li>
        <li><strong>Color Coding:</strong> Optional LC class color palettes for visual navigation</li>
      </ul>
      
      <h4>Scope</h4>
      <p>
        ShelfSignals ingests catalog records, normalizes metadata, and uses configurable
        analysis modules to detect patterns in:
      </p>
      <ul>
        <li>Numbering sequences and call number clustering</li>
        <li>Subject heading patterns and keyword analysis</li>
        <li>Provenance and physical location distributions</li>
        <li>Temporal groupings and acquisition patterns</li>
      </ul>
      
      <h4>Technology</h4>
      <p>
        This is a pure client-side web application built with vanilla JavaScript, CSS Grid, 
        and modern web standards. Data is loaded from JSON exports of library catalog records. 
        The visualization uses no external frameworks, making it lightweight and portable.
      </p>
      
      <p style="margin-top:1.5rem;padding-top:1rem;border-top:1px solid var(--border);font-size:0.85rem;color:var(--muted);">
        For more information, visit the 
        <a href="https://github.com/evcatalyst/ShelfSignals" target="_blank" rel="noopener noreferrer">ShelfSignals GitHub repository</a>.
      </p>
    </div>
  </div>
  <main class="layout">
    <section class="controls">
      <h2>Signals</h2>
      <div class="filter-group">
        <label><input type="checkbox" value="image" checked> Image / photo / cinema</label>
        <label><input type="checkbox" value="labor" checked> Labor / work / class</label>
        <label><input type="checkbox" value="capital" checked> Capital / empire</label>
        <label><input type="checkbox" value="sea" checked> Sea / ports / maritime</label>
        <label><input type="checkbox" value="cities" checked> Cities / logistics</label>
        <label><input type="checkbox" value="war" checked> War / policing</label>
        <label><input type="checkbox" value="borders" checked> Borders / migration</label>
        <label><input type="checkbox" value="archives" checked> Archives / museums</label>
        <label><input type="checkbox" value="art" checked> Art / artists / literature</label>
        <label><input type="checkbox" value="theory" checked> Theory / philosophy</label>
      </div>
      <div class="filter-group">
        <label for="searchBox" style="font-weight:600;font-size:0.9rem;">Search titles / subjects</label>
        <input id="searchBox" type="text" placeholder="Search..." />
      </div>
      <div class="filter-group">
        <label style="display:flex;align-items:center;gap:0.35rem;font-weight:600;font-size:0.9rem;">
          <input id="toggleClassColors" type="checkbox"> Color spines by LC class
        </label>
      </div>
      <h2>Legend</h2>
      <div class="legend">
        <div class="legend-chip">
          <span class="symbol" style="border-style:solid;"></span>
          <span>Image / media</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:dashed;"></span>
          <span>Labor / class</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-radius:0;"></span>
          <span>Sea / logistics</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-width:2px;"></span>
          <span>Capital / empire</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:dotted;"></span>
          <span>Theory / method</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:double;"></span>
          <span>Cities / logistics</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:solid;border-color:#999;"></span>
          <span>War / policing</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:solid;border-color:#555;"></span>
          <span>Borders / migration</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:solid;border-color:#777;"></span>
          <span>Archives / museums</span>
        </div>
        <div class="legend-chip">
          <span class="symbol" style="border-style:solid;border-color:#444;"></span>
          <span>Art / literature</span>
        </div>
      </div>
    </section>

    <section class="shelf-view">
      <h2>Shelf segments</h2>
      <div id="shelfSummary" class="section-subline"></div>
      <div id="locationChips" class="location-chips"></div>
      <div id="classLegend" class="class-legend"></div>
      <div id="clusterPanel" class="cluster-panel">
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.4rem;">
          <h2 style="margin:0;">Cluster map</h2>
          <div class="cluster-actions">
            <div id="clusterSummary" class="muted" style="font-size:0.8rem;"></div>
            <button id="btnToggleCluster" class="link-button" type="button">Hide</button>
            <button id="btnCollapseCluster" class="link-button" type="button">Collapse</button>
          </div>
        </div>
        <div id="locationOverview" class="location-overview"></div>
        <div id="clusterMap" class="cluster-map"></div>
      </div>
      <div id="shelfRows" class="shelf-rows"></div>
    </section>

    <aside class="detail">
      <h2>Details</h2>
      <div id="detailIntro" class="muted" style="font-size:0.8rem;">
        Select a shelf segment to see sample titles and their signals.
      </div>
      <div id="detailBody" class="detail-body"></div>
    </aside>
  </main>

  <script type="module">
    const activeThemes = new Set([
      "image",
      "labor",
      "capital",
      "sea",
      "cities",
      "war",
      "borders",
      "archives",
      "art",
      "theory"
    ]);
    let inventory = [];
    let selectedBook = null;
    let selectedCluster = null;
    let selectedLocation = null;
    let searchQuery = "";
    const locationFilter = new Set();
    let locationCounts = [];
    const SPINES_PER_RUN = 80;
    const CLUSTER_PAGE_SIZE = 40;
    let clusters = {};
    let clusterVisible = true;
    let clusterCollapsed = true;
    let colorByClass = false;
    const locationCollapsed = new Map();

    const PALETTES = {
      vivid: {
        label: "Vivid contrast",
        accent: "#1f77b4",
        chipBg: "#e0e7f5",
        colors: {
          A: "#1f77b4",
          B: "#ff7f0e",
          C: "#2ca02c",
          D: "#d62728",
          E: "#9467bd",
          F: "#8c564b",
          G: "#17becf",
          H: "#e4572e",
          J: "#f0b429",
          K: "#7b5aa6",
          L: "#1b9aaa",
          M: "#bcbd22",
          N: "#0f4c75",
          P: "#ff9f1c",
          Q: "#43aa8b",
          R: "#ef476f",
          S: "#118ab2",
          T: "#073b4c",
          U: "#f77f00",
          V: "#06d6a0",
          Z: "#d81e5b"
        }
      },
      warmStacks: {
        label: "Warm stacks",
        accent: "#b35c1e",
        chipBg: "#f1e6dd",
        colors: {
          A: "#b35c1e",
          B: "#c98b3b",
          C: "#a96c5d",
          D: "#7f3f2c",
          E: "#d9a441",
          F: "#8c5c38",
          G: "#c86f3c",
          H: "#a8522e",
          J: "#d3b07b",
          K: "#b0704a",
          L: "#c15d3e",
          M: "#9c6236",
          N: "#7a4f2c",
          P: "#c47a3a",
          Q: "#aa5c3b",
          R: "#e0a15a",
          S: "#8f5e45",
          T: "#b88957",
          U: "#a05f2f",
          V: "#cba671",
          Z: "#8a5128"
        }
      },
      mutedStacks: {
        label: "Muted wood + paper",
        accent: "#7e8c99",
        chipBg: "#e9e8e4",
        colors: {
          A: "#7e8c99",
          B: "#9a8a78",
          C: "#6f7b6d",
          D: "#8c6f5c",
          E: "#bba48a",
          F: "#7a6a5f",
          G: "#8899a6",
          H: "#9c7b66",
          J: "#a7b0b8",
          K: "#7d7b73",
          L: "#a2a094",
          M: "#8a9b92",
          N: "#6f6d68",
          P: "#9f8b7a",
          Q: "#8c9aa5",
          R: "#a28e7c",
          S: "#7f8d99",
          T: "#9b8d82",
          U: "#8a7d73",
          V: "#b0a291",
          Z: "#7b7d86"
        }
      }
    };

    let CLASS_COLORS = PALETTES.vivid.colors;
    let activePalette = "vivid";
    const extraClassColors = new Map();

    const ZONE_LABELS = {
      studio: "Allan Studio Book Room",
      front_bedroom: "Front Bedroom",
      garden_shed: "Garden Shed",
      study: "Study",
      office: "Office",
      hallway: "Hallway",
      other: "Other"
    };

    const themeOrder = [
      "image",
      "labor",
      "capital",
      "sea",
      "cities",
      "war",
      "borders",
      "archives",
      "art",
      "theory"
    ];

    // Theme keywords you can tweak (10 themes)
    const THEME_KEYWORDS = {
      image: [
        /photograph/i, /photo\b/i, /camera/i, /cinema/i, /film\b/i, /motion picture/i,
        /documentary film/i, /visual/i, /media/i, /photojournalism/i
      ],
      labor: [
        /labor/i, /labour/i, /working class/i, /worker/i, /union/i, /strike/i,
        /factory/i, /industry/i, /industrial/i, /proletariat/i
      ],
      capital: [
        /capitalism/i, /socialism/i, /communism/i, /marx/i, /imperial/i, /empire/i,
        /colon/i, /neoliberal/i, /economic history/i, /political economy/i
      ],
      sea: [
        /harbor/i, /harbour/i, /port\b/i, /shipping/i, /dock/i, /maritime/i,
        /ocean/i, /sea\b/i, /seafaring/i, /naval/i, /merchant marine/i, /ship\b/i, /shipwreck/i
      ],
      cities: [
        /los angeles/i, /urban/i, /city\b/i, /cities and towns/i, /metropolitan/i,
        /infrastructure/i, /transport/i, /railroad/i, /road/i, /logistic/i
      ],
      war: [
        /war/i, /military/i, /armed forces/i, /militarism/i, /police/i, /policing/i,
        /prison/i, /penal/i, /security/i, /surveillance/i
      ],
      borders: [
        /emigration/i, /immigration/i, /migration/i, /refugee/i, /diaspora/i,
        /border/i, /citizenship/i
      ],
      archives: [
        /museum/i, /archive/i, /library/i, /collecting/i, /collection of/i, /exhibition/i, /institutions?/i
      ],
      art: [
        /art\b/i, /artist/i, /painting/i, /sculpture/i, /photography, artistic/i,
        /fiction/i, /poetry/i, /drama/i, /literature/i
      ],
      theory: [
        /philosophy/i, /theory/i, /aesthetic/i, /psychoanalys/i, /critical theory/i,
        /semiotic/i, /hermeneutic/i
      ]
    };

    const toText = (value, joiner = ", ") => {
      if (Array.isArray(value)) return value.filter(Boolean).join(joiner);
      return value || "";
    };

    // Extract a clean ISBN-10/13 string
    function extractIsbn(raw) {
      const candidates = [];
      if (!raw) return null;
      if (Array.isArray(raw)) candidates.push(...raw);
      else if (typeof raw === "string") candidates.push(...raw.split("|"));
      const clean = candidates
        .map(s => (s || "").replace(/[^0-9Xx]/g, ""))
        .find(s => s.length === 10 || s.length === 13);
      return clean || null;
    }

    function buildExternalLinks(book) {
      const links = [];
      if (book.record_url) {
        links.push({ label: "View in catalog", href: book.record_url });
      }
      const isbn = book.isbn;
      const query = encodeURIComponent(`${book.title} ${book.authors || ""}`.trim());
      if (isbn) {
        links.push({
          label: "Search Amazon",
          href: `https://www.amazon.com/s?k=${isbn}`
        });
        links.push({
          label: "Find near me (WorldCat)",
          href: `https://worldcat.org/search?q=bn%3A${isbn}`
        });
      } else if (query) {
        links.push({
          label: "Search Amazon",
          href: `https://www.amazon.com/s?k=${query}`
        });
        links.push({
          label: "Find near me (WorldCat)",
          href: `https://worldcat.org/search?q=ti%3A${query}`
        });
      }
      return links;
    }

    // Use subjects (split on |) and optional Sekula notes to derive themes
    function deriveThemes(subjectsRaw, notesRaw = "") {
      const candidates = [];
      const subjectsText = toText(subjectsRaw, " | ");
      if (subjectsText) {
        candidates.push(...subjectsText.split("|").map(s => s.trim()));
      }
      const notesText = toText(notesRaw, " | ");
      if (notesText) candidates.push(notesText);

      const haystack = candidates.join(" | ");
      const themes = new Set();
      for (const [theme, patterns] of Object.entries(THEME_KEYWORDS)) {
        if (patterns.some(re => re.test(haystack))) themes.add(theme);
      }
      return Array.from(themes);
    }

    // Parse provenance into zone_room (coarse) and zone_detail (full identifier)
    function parseProvenance(provenanceRaw) {
      const text = toText(provenanceRaw, " | ");
      if (!text) return { zone_room: "Other", zone_detail: "" };
      const match = text.match(/Sekula Library identifier:([^;|]+)/i);
      const zoneDetail = match ? match[1].trim() : "";
      const target = zoneDetail || text;

      const zoneMap = [
        { label: "Allan Studio Book Room", re: /allan studio book room/i },
        { label: "Garden Shed", re: /garden shed/i },
        { label: "Front Bedroom", re: /front bedroom/i },
        { label: "Bottom Front", re: /bottom front/i },
        { label: "Study", re: /\bstudy\b/i },
        { label: "Sally Living Room", re: /sally[- ]?living room/i },
        { label: "Office", re: /office/i },
        { label: "Hallway", re: /hallway/i }
      ];

      const zone_room = (zoneMap.find(z => z.re.test(target)) || { label: "Other" }).label;
      return { zone_room, zone_detail: zoneDetail };
    }

    // Extract Sekula internal S-number when present, strict NE2698 .S4637L pattern
    function deriveSNumber(callNumber) {
      if (!callNumber) return null;
      const m = callNumber.match(/NE2698\\s+\\.S4637L\\s+(\\d{3,5})/i);
      if (m) {
        const num = parseInt(m[1], 10);
        return Number.isFinite(num) ? num : null;
      }
      return null;
    }

    function renderDetailFromBook(book) {
      selectedCluster = null;
      selectedLocation = null;
      const intro = document.getElementById("detailIntro");
      const body = document.getElementById("detailBody");

      intro.textContent = "Selection details";
      body.innerHTML = "";

      const card = document.createElement("div");
      card.className = "book-card";

      const title = document.createElement("div");
      title.className = "book-title";
      title.textContent = book.title;

      const meta = document.createElement("div");
      meta.className = "book-meta";
      const parts = [];
      if (book.authors) parts.push(book.authors);
      if (book.year) parts.push(book.year);
      if (book.call_number) parts.push(book.call_number);
      meta.textContent = parts.join(" · ");

      const themesRow = document.createElement("div");
      themesRow.className = "book-meta";
      for (const t of book.themes || deriveThemes(book.subjects, book.notes)) {
        const pill = document.createElement("span");
        pill.className = "pill";
        pill.textContent = t;
        themesRow.appendChild(pill);
      }

      card.appendChild(title);
      card.appendChild(meta);
      if (themesRow.childElementCount) card.appendChild(themesRow);

      if (book.subjects) {
        const subjects = document.createElement("div");
        subjects.className = "book-subjects muted";
        subjects.textContent = book.subjects;
        card.appendChild(subjects);
      }

      if (book.notes) {
        const notes = document.createElement("div");
        notes.className = "book-subjects";
        notes.textContent = book.notes;
        card.appendChild(notes);
      }

      if (book.call_number_notes) {
        const loc = document.createElement("div");
        loc.className = "pill note";
        loc.textContent = book.call_number_notes;
        card.appendChild(loc);
      }

      const links = buildExternalLinks(book);
      if (links.length) {
        const linkWrap = document.createElement("div");
        linkWrap.style.display = "flex";
        linkWrap.style.flexDirection = "column";
        linkWrap.style.gap = "0.2rem";
        linkWrap.style.marginTop = "0.2rem";
        for (const l of links) {
          const a = document.createElement("a");
          a.href = l.href;
          a.target = "_blank";
          a.rel = "noreferrer";
          a.textContent = l.label;
          linkWrap.appendChild(a);
        }
        card.appendChild(linkWrap);
      }
      body.appendChild(card);
    }

    function renderDetailFromCluster(zone, theme, items, page = 0) {
      selectedBook = null;
      selectedCluster = { zone, theme, page };
      selectedLocation = null;
      const intro = document.getElementById("detailIntro");
      const body = document.getElementById("detailBody");
      intro.textContent = `Cluster: ${zoneLabel(zone)} · ${theme}`;
      body.innerHTML = "";

      const header = document.createElement("div");
      header.className = "book-card";
      const total = items.length;
      const sNumbers = items.map(i => i.sNumber).filter(n => typeof n === "number");
      const sMin = sNumbers.length ? Math.min(...sNumbers) : null;
      const sMax = sNumbers.length ? Math.max(...sNumbers) : null;
      const headerLine = document.createElement("div");
      headerLine.className = "book-meta";
      headerLine.textContent =
        `${total} item${total !== 1 ? "s" : ""}` +
        (sMin !== null && sMax !== null ? ` · S-range ${sMin}–${sMax}` : "");
      header.appendChild(headerLine);
      body.appendChild(header);

      const start = page * CLUSTER_PAGE_SIZE;
      const slice = items.slice(start, start + CLUSTER_PAGE_SIZE);

      for (const book of slice) {
        const card = document.createElement("div");
        card.className = "book-card";
        const title = document.createElement("div");
        title.className = "book-title";
        title.textContent = book.title;
        const meta = document.createElement("div");
        meta.className = "book-meta";
        const parts = [];
        if (book.authors) parts.push(book.authors);
        if (book.year) parts.push(book.year);
        if (book.call_number) parts.push(book.call_number);
        meta.textContent = parts.join(" · ");
        const themesRow = document.createElement("div");
        themesRow.className = "book-meta";
        for (const t of book.themes || deriveThemes(book.subjects, book.notes)) {
          const pill = document.createElement("span");
          pill.className = "pill";
          pill.textContent = t;
          themesRow.appendChild(pill);
        }
        const subjects = document.createElement("div");
        subjects.className = "book-subjects muted";
        subjects.textContent = book.subjects;

        card.appendChild(title);
        card.appendChild(meta);
        if (themesRow.childElementCount) card.appendChild(themesRow);
        if (book.subjects) card.appendChild(subjects);
        if (book.notes) {
          const notes = document.createElement("div");
          notes.className = "book-subjects";
          notes.textContent = book.notes;
          card.appendChild(notes);
        }
        if (book.call_number_notes) {
          const loc = document.createElement("div");
          loc.className = "pill note";
          loc.textContent = book.call_number_notes;
          card.appendChild(loc);
        }
        const links = buildExternalLinks(book);
        if (links.length) {
          const linkWrap = document.createElement("div");
          linkWrap.style.display = "flex";
          linkWrap.style.flexDirection = "column";
          linkWrap.style.gap = "0.2rem";
          linkWrap.style.marginTop = "0.2rem";
          for (const l of links) {
            const a = document.createElement("a");
            a.href = l.href;
            a.target = "_blank";
            a.rel = "noreferrer";
            a.textContent = l.label;
            linkWrap.appendChild(a);
          }
          card.appendChild(linkWrap);
        }

        body.appendChild(card);
      }

      if (total > CLUSTER_PAGE_SIZE) {
        const pager = document.createElement("div");
        pager.style.display = "flex";
        pager.style.justifyContent = "space-between";
        pager.style.alignItems = "center";
        pager.style.marginTop = "0.4rem";
        const info = document.createElement("div");
        info.className = "book-meta";
        info.textContent = `Showing ${start + 1}-${Math.min(start + CLUSTER_PAGE_SIZE, total)} of ${total}`;
        const controls = document.createElement("div");
        controls.style.display = "flex";
        controls.style.gap = "0.35rem";
        const prev = document.createElement("button");
        prev.className = "link-button";
        prev.textContent = "Prev";
        prev.disabled = page === 0;
        prev.addEventListener("click", () => {
          renderDetailFromCluster(zone, theme, items, page - 1);
        });
        const next = document.createElement("button");
        next.className = "link-button";
        next.textContent = "Next";
        next.disabled = start + CLUSTER_PAGE_SIZE >= total;
        next.addEventListener("click", () => {
          renderDetailFromCluster(zone, theme, items, page + 1);
        });
        controls.appendChild(prev);
        controls.appendChild(next);
        pager.appendChild(info);
        pager.appendChild(controls);
        body.appendChild(pager);
      }
    }

    function buildLocationOverviewData(items) {
      const map = new Map();
      for (const item of items) {
        for (const loc of item.locations) {
          if (!map.has(loc)) {
            map.set(loc, { count: 0, themes: {} });
          }
          const entry = map.get(loc);
          entry.count += 1;
          for (const t of item.themes.length ? item.themes : ["unclassified"]) {
            entry.themes[t] = (entry.themes[t] || 0) + 1;
          }
        }
      }
      return Array.from(map.entries())
        .map(([loc, data]) => ({ loc, ...data }))
        .sort((a, b) => b.count - a.count);
    }

    function renderLocationOverview(filteredItems) {
      const container = document.getElementById("locationOverview");
      container.innerHTML = "";
      if (clusterCollapsed) {
        container.style.display = "none";
        return;
      }
      container.style.display = "grid";

      const data = buildLocationOverviewData(filteredItems);
      if (!data.length) return;
      const themeKeys = themeOrder;
      const max = Math.max(...data.map(d => d.count));

      for (const row of data) {
        const card = document.createElement("div");
        card.className = "location-card";
        const header = document.createElement("div");
        header.className = "loc-header";
      const label = document.createElement("div");
      label.textContent = row.loc;
      const count = document.createElement("div");
      count.className = "loc-count";
      count.textContent = `${row.count} item${row.count !== 1 ? "s" : ""}`;
        header.appendChild(label);
        header.appendChild(count);
        card.appendChild(header);

        for (const t of themeKeys) {
          const c = row.themes[t] || 0;
          if (!c) continue;
          const barRow = document.createElement("div");
          barRow.className = "bar-row";
          const bar = document.createElement("div");
          bar.className = "bar";
          bar.style.width = `${Math.max(8, (c / max) * 100)}%`;
          const text = document.createElement("span");
          text.textContent = `${t} (${c})`;
          barRow.appendChild(text);
          barRow.appendChild(bar);
          card.appendChild(barRow);
        }

        card.addEventListener("click", () => {
          renderDetailFromLocation(row.loc, { count: row.count, themes: row.themes });
        });

        container.appendChild(card);
      }
    }

    function renderDetailFromLocation(locKey, stats) {
      selectedBook = null;
      selectedCluster = null;
      selectedLocation = locKey;
      const intro = document.getElementById("detailIntro");
      const body = document.getElementById("detailBody");
      intro.textContent = `Location: ${locKey}`;
      body.innerHTML = "";

      const card = document.createElement("div");
      card.className = "book-card";
      const total = stats.count;
      const header = document.createElement("div");
      header.className = "book-meta";
      header.textContent = `${total} item${total !== 1 ? "s" : ""}`;
      card.appendChild(header);

      const barWrap = document.createElement("div");
      barWrap.style.display = "flex";
      barWrap.style.flexDirection = "column";
      barWrap.style.gap = "0.25rem";

      const max = Math.max(...Object.values(stats.themes));
      for (const theme of themeOrder) {
        const count = stats.themes[theme] || 0;
        if (!count) continue;
        const row = document.createElement("div");
        row.className = "bar-row";
        const label = document.createElement("span");
        label.textContent = `${theme} (${count})`;
        const bar = document.createElement("div");
        bar.className = "bar";
        bar.style.width = `${Math.max(8, (count / max) * 100)}%`;
        row.appendChild(label);
        row.appendChild(bar);
        barWrap.appendChild(row);
      }

      card.appendChild(barWrap);
      body.appendChild(card);
    }

    function parseCallNumber(callNumber) {
      if (!callNumber) return { prefix: "Other", number: null, lcClass: "Other" };
      const match = callNumber.match(/^([A-Z]{1,3})\\s*([0-9]{1,4}(?:\\.[0-9]+)?)/i);
      const prefix = match ? match[1].toUpperCase() : "Other";
      const number = match ? parseFloat(match[2]) : null;
      const lcClass = prefix ? prefix[0] : "Other";
      return { prefix, number, lcClass };
    }

    function bandForCall(prefix, number) {
      if (number === null || Number.isNaN(number)) {
        return { id: `${prefix}-unknown`, label: `${prefix} (unshelved)`, order: [prefix, Infinity] };
      }
      const bucket = Math.floor(number / 100) * 100;
      const label = `${prefix} ${bucket}-${bucket + 99}`;
      return { id: `${prefix}-${bucket}`, label, order: [prefix, bucket] };
    }

    function parseLocations(notesRaw) {
      if (!notesRaw) return ["Unspecified"];
      const raw = Array.isArray(notesRaw) ? notesRaw.join(" | ") : notesRaw;
      return raw.split("|").map(s => s.trim()).filter(Boolean);
    }

    function normalizeItem(raw) {
      const call = raw.call_number || raw.callNumber || "";
      const { prefix, number, lcClass } = parseCallNumber(call);
      const band = bandForCall(prefix, number);
      const subjectsField = toText(raw.subjects || raw.subject_headings || "");
      const authorsField = toText(raw.authors);
      const notesField = toText(raw.sekula_notes);
      const themes = deriveThemes(subjectsField, notesField);
      const locations = parseLocations(raw.call_number_notes);
      const { zone_room, zone_detail } = parseProvenance(raw.provenance_notes);
      const sNumber = deriveSNumber(call);
      const isbn = extractIsbn(raw.isbns || raw.identifiers || raw.isbn || raw.isbn_10 || raw.isbn_13);

      return {
        id: raw.id || raw.alma_mms || null,
        title: raw.title || "Untitled",
        authors: authorsField,
        year: raw.year || "",
        subjects: subjectsField,
        notes: notesField,
        call_number: call,
        call_number_notes: raw.call_number_notes || "",
        record_url: raw.record_url || "",
        isbn,
        themes,
        locations,
        zone: zone_room,
        zone_room,
        zone_detail,
        sNumber,
        prefix,
        lcClass,
        classKey: prefix || lcClass,
        number: number ?? Infinity,
        bandId: band.id,
        bandLabel: band.label,
        bandOrder: band.order
      };
    }

    function getFilteredItems() {
      const query = searchQuery.trim().toLowerCase();
      return inventory.filter(item => {
        if (locationFilter.size > 0 && !item.locations.some(l => locationFilter.has(l))) {
          return false;
        }
        if (query) {
          const haystack = `${item.title} ${item.subjects}`.toLowerCase();
          if (!haystack.includes(query)) return false;
        }
        return true;
      });
    }

    function buildBands(items) {
      const map = new Map();
      for (const item of items) {
        const locKey = item.locations[0] || "Unspecified";
        const groupId = `${locKey}::${item.bandId}`;
        if (!map.has(groupId)) {
          map.set(groupId, {
            id: groupId,
            label: item.bandLabel,
            order: item.bandOrder,
            location: locKey,
            items: []
          });
        }
        map.get(groupId).items.push(item);
      }
      const bands = Array.from(map.values());
      bands.forEach(b => b.items.sort((a, b) => a.number - b.number || a.title.localeCompare(b.title)));
      bands.sort((a, b) => {
        if (a.location !== b.location) return a.location.localeCompare(b.location);
        if (a.order[0] !== b.order[0]) return a.order[0].localeCompare(b.order[0]);
        return a.order[1] - b.order[1];
      });
      return bands;
    }

    function formatRangeLabel(items) {
      if (!items.length) return "";
      const first = items[0].call_number || "First";
      const last = items[items.length - 1].call_number || "Last";
      return `${first} → ${last}`;
    }

    function chunkSpines(items, size = SPINES_PER_RUN) {
      const chunks = [];
      for (let i = 0; i < items.length; i += size) {
        chunks.push(items.slice(i, i + size));
      }
      return chunks;
    }

    function lightenHex(hex, amount = 0.4) {
      const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      if (!m) return hex;
      const [r, g, b] = m.slice(1).map(x => parseInt(x, 16));
      const mix = (c) => Math.round(c + (255 - c) * amount);
      const toHex = (n) => n.toString(16).padStart(2, "0");
      return `#${toHex(mix(r))}${toHex(mix(g))}${toHex(mix(b))}`;
    }

    function getClassColor(key, fallbackKey) {
      const paletteColors = Object.values(CLASS_COLORS);
      if (CLASS_COLORS[key]) return CLASS_COLORS[key];
      if (fallbackKey && CLASS_COLORS[fallbackKey]) return CLASS_COLORS[fallbackKey];
      const first = key?.[0] || fallbackKey?.[0];
      if (first && CLASS_COLORS[first]) return CLASS_COLORS[first];
      if (extraClassColors.has(key)) return extraClassColors.get(key);
      const color = paletteColors[extraClassColors.size % paletteColors.length] || "#8aa6c1";
      extraClassColors.set(key, color);
      return color;
    }

    function zoneLabel(key) {
      return ZONE_LABELS[key] || key;
    }

    function applyPalette(key) {
      if (!PALETTES[key]) return;
      activePalette = key;
      CLASS_COLORS = PALETTES[key].colors;
      // Ensure class colors are active when choosing a palette
      colorByClass = true;
      const cb = document.getElementById("toggleClassColors");
      if (cb) cb.checked = true;
      const accent = PALETTES[key].accent || getComputedStyle(document.documentElement).getPropertyValue("--accent");
      const chipBg = PALETTES[key].chipBg || getComputedStyle(document.documentElement).getPropertyValue("--chip-bg");
      document.documentElement.style.setProperty("--accent", accent);
      document.documentElement.style.setProperty("--chip-bg", chipBg);
      renderClassLegend();
      renderShelfRows();
      renderPaletteGrid();
    }

    // Build cluster summary by workspace zone and theme
    function buildClusters(items) {
      const result = {};
      for (const item of items) {
        const zoneKey = item.zone || "other";
        if (!result[zoneKey]) result[zoneKey] = {};
        const zoneBucket = result[zoneKey];

        const itemThemes = item.themes.length ? item.themes : ["unclassified"];
        for (const theme of itemThemes) {
          if (!zoneBucket[theme]) {
            zoneBucket[theme] = {
              count: 0,
              exampleTitles: [],
              sNumberMin: null,
              sNumberMax: null
            };
          }
          const bucket = zoneBucket[theme];
          bucket.count += 1;
          if (bucket.exampleTitles.length < 5) {
            bucket.exampleTitles.push(item.title);
          }
          if (typeof item.sNumber === "number") {
            if (bucket.sNumberMin === null || item.sNumber < bucket.sNumberMin) {
              bucket.sNumberMin = item.sNumber;
            }
            if (bucket.sNumberMax === null || item.sNumber > bucket.sNumberMax) {
              bucket.sNumberMax = item.sNumber;
            }
          }
        }
      }
      return result;
    }

    function renderShelfRows() {
      const container = document.getElementById("shelfRows");
      const summary = document.getElementById("shelfSummary");
      container.innerHTML = "";

      const filtered = getFilteredItems();
      const bands = buildBands(filtered);
      const activeLabels = themeOrder.filter(t => activeThemes.has(t));
      const byLocation = new Map();
      for (const band of bands) {
        if (!byLocation.has(band.location)) byLocation.set(band.location, []);
        byLocation.get(band.location).push(band);
      }

      summary.textContent =
        `${filtered.length} items · ${bands.length} bands · ${byLocation.size} locations` +
        (locationFilter.size ? ` · locations: ${Array.from(locationFilter).join(", ")}` : "") +
        (searchQuery ? ` · search: "${searchQuery}"` : "") +
        (activeLabels.length && activeLabels.length < themeOrder.length
          ? ` · themes: ${activeLabels.join(", ")}`
          : "");

      // Order locations by overall counts (locationCounts) then alpha
      const locationOrder = [
        ...locationCounts.map(l => l.label),
        ...Array.from(byLocation.keys())
      ].filter((v, i, arr) => arr.indexOf(v) === i);

      for (const loc of locationOrder) {
        const locBands = byLocation.get(loc);
        if (!locBands || !locBands.length) continue;
        const totalLocItems = locBands.reduce((sum, b) => sum + b.items.length, 0);

        const section = document.createElement("div");
        section.className = "location-section";

        const locHeader = document.createElement("div");
        locHeader.className = "location-header";
        const locTitle = document.createElement("div");
        locTitle.className = "location-title";
        locTitle.textContent = loc;
        const locCount = document.createElement("div");
        locCount.className = "location-count";
        locCount.textContent = `${totalLocItems} title${totalLocItems !== 1 ? "s" : ""}`;
        const locToggle = document.createElement("button");
        locToggle.type = "button";
        locToggle.className = "link-button";
        const collapsed = locationCollapsed.get(loc) === true;
        locToggle.textContent = collapsed ? "Expand" : "Collapse";
        locHeader.appendChild(locTitle);
        locHeader.appendChild(locCount);
        locHeader.appendChild(locToggle);
        section.appendChild(locHeader);

        locToggle.addEventListener("click", () => {
          const isCollapsed = locationCollapsed.get(loc) === true;
          locationCollapsed.set(loc, !isCollapsed);
          renderShelfRows();
        });

        const locBody = document.createElement("div");
        locBody.className = "location-body";
        locBody.style.display = collapsed ? "none" : "flex";

        for (const band of locBands) {
          const row = document.createElement("div");
          row.className = "shelf-row";

          const header = document.createElement("div");
          header.className = "shelf-row-header";

          const label = document.createElement("div");
          label.className = "shelf-row-label";
          label.textContent = band.label;

          const count = document.createElement("div");
          count.className = "shelf-row-count";
          count.textContent = `${band.items.length} title${band.items.length !== 1 ? "s" : ""}`;

          header.appendChild(label);
          header.appendChild(count);

          const spines = document.createElement("div");
          spines.className = "spines";

          const runs = chunkSpines(band.items, SPINES_PER_RUN);
          runs.forEach(runItems => {
            const runLabel = document.createElement("div");
            runLabel.className = "spine-run-label";
            runLabel.textContent = formatRangeLabel(runItems);

            const run = document.createElement("div");
            run.className = "spine-run";

            for (const item of runItems) {
              const matchesTheme =
                activeThemes.size === 0 ||
                item.themes.some(t => activeThemes.has(t));

              const spine = document.createElement("div");
              spine.className = "spine";
              spine.dataset.id = item.id || "";
              spine.dataset.highlight = matchesTheme ? "true" : "false";
              spine.dataset.dimmed = matchesTheme ? "false" : "true";
              spine.title = `${item.title} \\n${item.call_number}`;
              if (colorByClass) {
                const c = getClassColor(item.classKey, item.lcClass);
                spine.style.background = lightenHex(c, 0.6);
                spine.style.borderColor = c;
              } else {
                spine.style.background = "#fff";
                spine.style.borderColor = "";
              }
              spine.addEventListener("click", () => {
                selectedBook = item;
                renderDetailFromBook(item);
              });

              run.appendChild(spine);
            }

            spines.appendChild(runLabel);
            spines.appendChild(run);
          });

          row.appendChild(header);
          row.appendChild(spines);
          locBody.appendChild(row);
        }

        section.appendChild(locBody);
        container.appendChild(section);
      }

      renderClusterMap(filtered);
    }

    function renderClusterMap(filteredItems) {
      const container = document.getElementById("clusterMap");
      const summary = document.getElementById("clusterSummary");
      const panel = document.getElementById("clusterPanel");
      panel.style.display = clusterVisible ? "block" : "none";
      const btnToggle = document.getElementById("btnToggleCluster");
      const btnCollapse = document.getElementById("btnCollapseCluster");
      btnToggle.textContent = clusterVisible ? "Hide" : "Show";
      btnCollapse.textContent = clusterCollapsed ? "Expand" : "Collapse";
      if (!clusterVisible) return;
      container.innerHTML = "";
      const data = buildClusters(filteredItems);
      const zones = Object.entries(data).map(([zone, themes]) => {
        const total = Object.values(themes).reduce((acc, t) => acc + t.count, 0);
        return { zone, themes, total };
      }).sort((a, b) => b.total - a.total);

      const totalItems = filteredItems.length;
      summary.textContent = `${zones.length} zones · ${totalItems} items in view`;

      if (clusterCollapsed) {
        container.style.display = "none";
      } else {
        container.style.display = "grid";
      }

      renderLocationOverview(filteredItems);

      const themeList = [...themeOrder, "unclassified"];

      let maxCount = 0;
      for (const z of zones) {
        for (const t of Object.values(z.themes)) {
          if (t.count > maxCount) maxCount = t.count;
        }
      }

      for (const { zone, themes, total } of zones) {
        const card = document.createElement("div");
        card.className = "cluster-card";

        const header = document.createElement("div");
        header.className = "cluster-card-header";
        const zLabel = document.createElement("div");
        zLabel.className = "cluster-zone";
        zLabel.textContent = zoneLabel(zone);
        const zCount = document.createElement("div");
        zCount.className = "cluster-count";
        zCount.textContent = `${total} item${total !== 1 ? "s" : ""}`;
        const toggle = document.createElement("button");
        toggle.type = "button";
        toggle.className = "link-button";
        toggle.textContent = "Collapse";
        header.appendChild(zLabel);
        header.appendChild(zCount);
        header.appendChild(toggle);
        card.appendChild(header);

        const cells = document.createElement("div");
        cells.className = "cluster-cells";
        cells.dataset.collapsed = "false";

        for (const theme of themeList) {
          const bucket = themes[theme];
          if (!bucket) continue;
          const cell = document.createElement("div");
          cell.className = "cluster-cell";
          cell.dataset.active = activeThemes.has(theme) ? "true" : "false";
          cell.style.cursor = "pointer";

          const label = document.createElement("div");
          label.className = "cluster-cell-label";
          label.textContent = `${theme} (${bucket.count})`;
          cell.appendChild(label);

          const bar = document.createElement("div");
          bar.className = "cluster-bar";
          const width = maxCount ? Math.max(8, (bucket.count / maxCount) * 100) : 0;
          bar.style.width = `${width}%`;
          cell.appendChild(bar);

          const meta = document.createElement("div");
          meta.className = "cluster-meta";
          const parts = [];
          if (bucket.sNumberMin !== null && bucket.sNumberMax !== null) {
            parts.push(`S-range: ${bucket.sNumberMin}–${bucket.sNumberMax}`);
          }
          if (bucket.exampleTitles.length) {
            parts.push(`e.g. ${bucket.exampleTitles.slice(0, 3).join(" · ")}`);
          }
          meta.textContent = parts.join(" · ");
          cell.appendChild(meta);

          cell.addEventListener("click", () => {
            const itemsForCluster = filteredItems.filter(
              i =>
                (i.zone || "other") === zone &&
                (i.themes.length ? i.themes.includes(theme) : theme === "unclassified")
            );
            renderDetailFromCluster(zone, theme, itemsForCluster, 0);
          });

          cells.appendChild(cell);
        }

        toggle.addEventListener("click", () => {
          const isCollapsed = cells.dataset.collapsed === "true";
          cells.dataset.collapsed = isCollapsed ? "false" : "true";
          toggle.textContent = isCollapsed ? "Collapse" : "Expand";
        });

        card.appendChild(cells);
        container.appendChild(card);
      }
    }

    function computeLocationCounts() {
      const counts = new Map();
      for (const item of inventory) {
        for (const loc of item.locations) {
          counts.set(loc, (counts.get(loc) || 0) + 1);
        }
      }
      locationCounts = Array.from(counts.entries())
        .map(([label, count]) => ({ label, count }))
        .sort((a, b) => b.count - a.count);
    }

    function renderLocationChips() {
      const container = document.getElementById("locationChips");
      container.innerHTML = "";

      const makeChip = (label, count, active) => {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.dataset.active = active ? "true" : "false";
        chip.textContent = `${label}${count !== null ? ` (${count})` : ""}`;
        chip.addEventListener("click", () => {
          if (label === "All locations") {
            locationFilter.clear();
          } else {
            if (locationFilter.has(label)) {
              locationFilter.delete(label);
            } else {
              locationFilter.add(label);
            }
          }
          renderLocationChips();
          renderShelfRows();
        });
        return chip;
      };

      container.appendChild(makeChip("All locations", inventory.length, locationFilter.size === 0));

      for (const { label, count } of locationCounts) {
        container.appendChild(makeChip(label, count, locationFilter.has(label)));
      }
    }

    function renderClassLegend() {
      const container = document.getElementById("classLegend");
      container.innerHTML = "";
      if (!colorByClass) return;
      const present = new Set(inventory.map(i => i.classKey || i.lcClass));
      const keys = Array.from(present).sort();
      const heading = document.createElement("div");
      heading.style.fontWeight = "700";
      heading.style.fontSize = "0.85rem";
      heading.style.marginBottom = "0.35rem";
      heading.textContent = "LC class colors";
      container.appendChild(heading);
      for (const key of keys) {
        const chip = document.createElement("div");
        chip.className = "class-chip";
        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = getClassColor(key, key[0]);
        chip.appendChild(sw);
        const label = document.createElement("span");
        label.textContent = key;
        chip.appendChild(label);
        container.appendChild(chip);
      }
    }

    function renderPaletteGrid() {
      const grid = document.getElementById("paletteGrid");
      grid.innerHTML = "";
      for (const [key, entry] of Object.entries(PALETTES)) {
        const card = document.createElement("div");
        card.className = "palette-card";
        card.dataset.active = key === activePalette ? "true" : "false";
        const title = document.createElement("div");
        title.textContent = entry.label;
        title.style.fontWeight = 600;
        title.style.fontSize = "0.9rem";
        card.appendChild(title);
        const swRow = document.createElement("div");
        swRow.className = "swatch-row";
        Object.values(entry.colors).slice(0, 6).forEach(c => {
          const sw = document.createElement("div");
          sw.className = "swatch-square";
          sw.style.background = c;
          swRow.appendChild(sw);
        });
        card.appendChild(swRow);
        card.addEventListener("click", () => {
          applyPalette(key);
          renderPaletteGrid();
        });
        grid.appendChild(card);
      }
    }

    function attachFilterHandlers() {
      const themeCheckboxes = Array.from(
        document.querySelectorAll(".filter-group input[type='checkbox']")
      ).filter(cb => themeOrder.includes(cb.value));

      themeCheckboxes.forEach(cb => {
        cb.addEventListener("change", () => {
          if (cb.checked) {
            activeThemes.add(cb.value);
          } else {
            activeThemes.delete(cb.value);
          }
          renderShelfRows();
        });
      });

      const searchBox = document.getElementById("searchBox");
      searchBox.addEventListener("input", () => {
        searchQuery = searchBox.value || "";
        renderShelfRows();
      });

      const toggleClassColors = document.getElementById("toggleClassColors");
      toggleClassColors.addEventListener("change", () => {
        colorByClass = toggleClassColors.checked;
        renderClassLegend();
        renderShelfRows();
      });

      const btnToggleCluster = document.getElementById("btnToggleCluster");
      const btnCollapseCluster = document.getElementById("btnCollapseCluster");
      btnToggleCluster.addEventListener("click", () => {
        clusterVisible = !clusterVisible;
        renderClusterMap(getFilteredItems());
      });
      btnCollapseCluster.addEventListener("click", () => {
        clusterCollapsed = !clusterCollapsed;
        renderClusterMap(getFilteredItems());
      });

      const openConfig = document.getElementById("openConfig");
      const closeConfig = document.getElementById("closeConfig");
      const backdrop = document.getElementById("configBackdrop");
      openConfig.addEventListener("click", () => {
        renderPaletteGrid();
        backdrop.style.display = "flex";
      });
      closeConfig.addEventListener("click", () => {
        backdrop.style.display = "none";
      });
      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) backdrop.style.display = "none";
      });

      const openAbout = document.getElementById("openAbout");
      const closeAbout = document.getElementById("closeAbout");
      const aboutBackdrop = document.getElementById("aboutBackdrop");
      openAbout.addEventListener("click", () => {
        aboutBackdrop.style.display = "flex";
        closeAbout.focus();
      });
      closeAbout.addEventListener("click", () => {
        aboutBackdrop.style.display = "none";
        openAbout.focus();
      });
      aboutBackdrop.addEventListener("click", (e) => {
        if (e.target === aboutBackdrop) {
          aboutBackdrop.style.display = "none";
          openAbout.focus();
        }
      });

      // ESC key closes modals
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (aboutBackdrop.style.display === "flex") {
            aboutBackdrop.style.display = "none";
            openAbout.focus();
          } else if (backdrop.style.display === "flex") {
            backdrop.style.display = "none";
            openConfig.focus();
          }
        }
      });
    }

    async function init() {
      const loading = document.getElementById("loadingOverlay");
      loading.style.display = "flex";
      attachFilterHandlers();

      try {
        const response = await fetch("data/sekula_inventory.json");
        if (!response.ok) {
          throw new Error("Failed to load JSON");
        }
        const data = await response.json();
        const rawItems = Array.isArray(data) ? data : (data.items || []);
        inventory = rawItems
          .filter(item => (item.collection || "").includes("Allan Sekula Library"))
          .map(normalizeItem);
        clusters = buildClusters(inventory);
        // Expose clusters for inspection in devtools
        window.shelfsignalsClusters = clusters;
        computeLocationCounts();
        renderLocationChips();
        renderClassLegend();
        renderShelfRows();
        renderClusterMap(getFilteredItems());
        if (selectedCluster) {
          const items = getFilteredItems().filter(
            i =>
              (i.zone || "other") === selectedCluster.zone &&
              (i.themes.length ? i.themes.includes(selectedCluster.theme) : selectedCluster.theme === "unclassified")
          );
          if (items.length) {
            renderDetailFromCluster(selectedCluster.zone, selectedCluster.theme, items, selectedCluster.page || 0);
          }
        }
        loading.style.display = "none";
      } catch (err) {
        console.error(err);
        const summary = document.getElementById("shelfSummary");
        summary.textContent =
          "Could not load sekula_inventory.json – check the file path or run from a local server.";
        loading.style.display = "none";
      }
    }

    init();
  </script>
</body>
</html>
